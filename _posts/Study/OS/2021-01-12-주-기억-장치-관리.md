---
layout: post
title: "주 기억 장치(Memory) 관리"
categories:
  - Study
  - OS
tags:
  - OS
created_at: 2021-01-12T22:43:00+09:00
modified_at: 2021-01-12T22:43:00+09:00
visible: true
---

## 주 기억 장치 관리란?

주 기억 장치(Memory)는 명령어나 데이터 저장를 저장하는 CPU가 직접 접근이 가능한 장치이다.

CPU를 빌려서 사용하는 프로세스가 수행되기 위해 필요한 정보들이 수시로 탑재되고 교체되기 때문에 주 기억 장치에 적절한 크기의 데이터를 적절할 위치에 탑재하고 적절한 시기에 교체하는 것이 중요하다.

### 주소 바인딩

메모리는 데이터가 저장되는 물리적인 공간을 지정할 수 있는 **주소**와 저장된 **데이터**로 구성되어 있다.

다음과 같은 3단계 과정을 거쳐 최종적으로 메모리의 주소 바인딩이 이루어진다

1. 소스 코드 컴파일 단계
   * 프로그래머가 작성한 소스 코드를 컴퓨터가 인식할 수 있는 기계어로 번역(컴파일)한 목적 코드로 변환한다.
2. 프로그램에 필요한 라이브러리를 목적 코드에 Link
   * 소스 코드 작성시 외부의 라이브러리를 통해 추가한 모듈을 Linker가 연결해 실행 가능한 코드(프로그램)를 생성한다.
   * 이때 프로그램에서 사용하는 주소들을 재배치 가능한 주소에 바인딩한다(논리 주소 : 재배치 가능 주소)
3. 프로그램을 메모리에 Load
   * 실행 가능한 프로그램이 Loader에 의해 된다.
   * 이때 재배치 가능한 주소와 실제 메모리 주소를 바인딩한다.(논리 주소 : 재배치 가능 주소 : 실제 주소)

* 프로세스가 실행 될 때 마다 항상 같은 메모리 주소에 바인딩 된다는 보장이 없으므로 이러한 과정을 통해서 프로그램 작성 시 실제 주소를 신경 쓰지 않고 코드를 작성할 수 있도록 한다.
* Memory Management Unit(MMU)
  * 대개 프로그램에서 사용하는 논리(가상) 주소는 실제 메모리의 크기보다 크고, 항상 같은 주소에 바인딩된다는 보장이 없으므로 논리 주소를 실제 주소와 바인딩해주는 중간과정이 필요하다.
  * 이를 담당하는 것이 MMU이다.



### 동적 적재, 동적 연결

주소 바인딩 과정에서 중복되거나 불필요한 코드가 Load되어 메모리를 낭비하는 것을 방지하기 위한 기술이다

#### 동적 적재

* 프로그램을 독립적으로 실행할 수 있는 루틴 단위(if문, exception 등)로 분할하고 저장해놨다가 사용해야 할 상황이 오게되었을 때 메모리에 적재한다.

* if문 같은 경우 특정 상황에서만 내부 코드가 수행되기 때문에 일단 해당 루틴은 적재하지 않고 있다가 if문 내부 코드가 수행되어야 하는 상황이 오면 저장되어있는 루틴을 찾아 메모리에 적재하고 실행한다.

#### 동적 연결

* 동일한 라이브러리를 사용하는 프로그램이 동시에 메모리에 올라가는 경우 똑같은 코드가 두번 적재되는 일이 발생한다.
* 기존에는 컴파일 완료 후 Link과정을 수행했다면 동적 연결은 프로그램 실행 과정에서 Link과정을 수행한다.
* 이 경우 이미 메모리에 적재된 라이브러리가 존재하면 추가로 Load하지 않고 이미 탑재된 라이브러리에 Link하여 메모리 공간을 절약할 수 있다.



### Overlay

* 메모리보다 크기가 큰 용량의 프로그램을 적재하기 위해 생긴 기술이다.
* 프로그램을 메모리보다 작은 크기로 분할하여 저장하고 프로세스의 실행에 꼭 필요한 부분만 메모리에 적재하여 실행하는 방식이다.
* 프로그램을 쪼개는 과정을 프로그래머가 수행하기 때문에 많은 시간이 소비된다.



### Swapping

* 현재 수행중이지 않은 프로세스의 정보들을 보조기억장치로 내리고 실행하고자 하는 프로세스의 정보들 메모리에 적재하는 것 Swapping이라고 한다.
* 과거에는 프로그램 코드 전체를 Swap-in 해서 프로세스를 진행하고 프로세스 교체시 Swap-out해 다른 프로그램 코드를 적재했다.
  * 현재는 프로그램 크기가 메모리에 비해 매우 커졌고
  * 불필요한 코드가 같이 적재되어 Context Switching 시 자원낭비가 심하며
  * 하나의 메모리에 다수의 프로세스가 접근하여 같이 사용하기 때문에 잘 사용되지 않음
  * 페이징 기법으로 발전하였다.

---

## 연속 메모리 할당 기법

