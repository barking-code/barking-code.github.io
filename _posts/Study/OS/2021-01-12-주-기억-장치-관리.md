---
layout: post
title: "주 기억 장치(Memory) 관리"
categories:
  - Study
  - OS
tags:
  - OS
created_at: 2021-01-12T22:43:00+09:00
modified_at: 2021-01-14T16:43:00+09:00
visible: true
---

## 주 기억 장치 관리란?

주 기억 장치(Memory)는 명령어나 데이터 저장를 저장하는 CPU가 직접 접근이 가능한 장치이다.

CPU를 빌려서 사용하는 프로세스가 수행되기 위해 필요한 정보들이 수시로 탑재되고 교체되기 때문에 주 기억 장치에 적절한 크기의 데이터를 적절할 위치에 탑재하고 적절한 시기에 교체하는 것이 중요하다.

### 주소 바인딩

메모리는 데이터가 저장되는 물리적인 공간을 지정할 수 있는 **주소**와 저장된 **데이터**로 구성되어 있다.

다음과 같은 3단계 과정을 거쳐 최종적으로 메모리의 주소 바인딩이 이루어진다

1. 소스 코드 컴파일 단계
   * 프로그래머가 작성한 소스 코드를 컴퓨터가 인식할 수 있는 기계어로 번역(컴파일)한 **목적 코드로 변환**한다.
2. 프로그램에 필요한 라이브러리를 목적 코드에 Link
   * 소스 코드 작성시 외부의 라이브러리를 통해 추가한 모듈을 Linker가 연결해 실행 가능한 코드(프로그램)를 생성한다.
   * 이때 프로그램에서 사용하는 주소들을 재배치 가능한 주소에 바인딩한다(논리 주소 : 재배치 가능 주소)
3. 프로그램을 메모리에 Load
   * 실행 가능한 프로그램이 Loader에 의해 된다.
   * 이때 재배치 가능한 주소와 실제 메모리 주소를 바인딩한다.(논리 주소 : 재배치 가능 주소 : 실제 주소)

* 프로세스가 실행 될 때 마다 항상 같은 메모리 주소에 바인딩 된다는 보장이 없으므로 이러한 과정을 통해서 프로그램 작성 시 실제 주소를 신경 쓰지 않고 코드를 작성할 수 있도록 한다.
* Memory Management Unit(MMU)
  * 대개 프로그램에서 사용하는 논리(가상) 주소는 실제 메모리의 크기보다 크고, 항상 같은 주소에 바인딩된다는 보장이 없으므로 논리 주소를 실제 주소와 바인딩해주는 중간과정이 필요하다.
  * 이를 담당하는 것이 MMU이다.



### 동적 적재, 동적 연결

주소 바인딩 과정에서 중복되거나 불필요한 코드가 Load되어 메모리를 낭비하는 것을 방지하기 위한 기술이다

#### 동적 적재

* 프로그램을 독립적으로 실행할 수 있는 루틴 단위(if문, exception 등)로 분할하고 저장해놨다가 사용해야 할 상황이 오게되었을 때 메모리에 적재한다.

* if문 같은 경우 특정 상황에서만 내부 코드가 수행되기 때문에 일단 해당 루틴은 적재하지 않고 있다가 if문 내부 코드가 수행되어야 하는 상황이 오면 저장되어있는 루틴을 찾아 메모리에 적재하고 실행한다.

#### 동적 연결

* 동일한 라이브러리를 사용하는 프로그램이 동시에 메모리에 올라가는 경우 똑같은 코드가 두번 적재되는 일이 발생한다.
* 기존에는 컴파일 완료 후 Link과정을 수행했다면 동적 연결은 프로그램 실행 과정에서 Link과정을 수행한다.
* 이 경우 이미 메모리에 적재된 라이브러리가 존재하면 추가로 Load하지 않고 이미 탑재된 라이브러리에 Link하여 메모리 공간을 절약할 수 있다.



### Overlay

* 메모리보다 크기가 큰 용량의 프로그램을 적재하기 위해 생긴 기술이다.
* 프로그램을 메모리보다 작은 크기로 분할하여 저장하고 프로세스의 실행에 꼭 필요한 부분만 메모리에 적재하여 실행하는 방식이다.
* 프로그램을 쪼개는 과정을 프로그래머가 수행하기 때문에 많은 시간이 소비된다.



### Swapping

* 현재 수행중이지 않은 프로세스의 정보들을 보조기억장치로 내리고 실행하고자 하는 프로세스의 정보들 메모리에 적재하는 것 Swapping이라고 한다.
* 과거에는 프로그램 코드 전체를 Swap-in 해서 프로세스를 진행하고 프로세스 교체시 Swap-out해 다른 프로그램 코드를 적재했다.
  * 현재는 프로그램 크기가 메모리에 비해 매우 커졌고
  * 불필요한 코드가 같이 적재되어 Context Switching 시 자원낭비가 심하며
  * 하나의 메모리에 다수의 프로세스가 접근하여 같이 사용하기 때문에 잘 사용되지 않음
  * 페이징 기법으로 발전하였다.

---

## 연속 메모리 할당 기법

> 하나의 프로그램이 메모리 상에 하나의 덩어리(연속적)로 적재되는 방법

### 단일 연속 할당 기법

* 단일 사용자가 메모리를 전부 점유하여 사용하는 방식
* 한번에 1개의 프로그램 코드가 메모리에 적재된다
* 메모리의 크기보다 큰 프로그램을 구동 하지 못하거나 오버레이 기법을 사용해야 한다.

### 분할 연속 할당 기법

* 다중 프로그래밍 환경에서 호율적인 실행을 위해 다수의 프로그램이 메모리를 공유하여 사용해야함
* 운영체제가 실행되기 위해 필요한 메모리 공간을 제외한 나머지 메모리 공간을 분할하여 다수의 프로그램(프로세스)에 할당한다.
* 메모리 공간이 분할 된 수만큼 프로세스가 동시에 실행될 수 있다.
* 메모리 공간이 낭비되는 단편화 현상이 발생한다.
  * 내부 단편화: 큰 메모리 공간에 작은 프로그램 코드가 할당되어 남는 공간
  * 외부 단편화: 작은 메모리 공간에 큰 프로그램 코드가 할당되지 못해 분할된 메모리 공간 전체가  남는 공간
* 메모리 공간을 분할하는 방법에 따라 고정 분할 기법과 가변 분할 기법으로 나뉜다.

#### 고정 분할 기법

* 메모리의 공간을 미리 정해진 크기대로 분할하여 사용한다.
* 단편화 현상이 많이 발생한다.

#### 가변 분할 기법

* 프로그램이 요구하는 크기에 맞게 요구하는 시점에 메모리를 분할하여 할당하고, 사용하지 않는 메모리는 회수한다.

* 메모리 공간을 할당하는 방법에 의해 배치된다.
  * 최초 적합 전략: 프로그램 코드가 탑재될 수 있는 크기의 메모리 공간을 만나면 탑재한다.
  * 최적 적합 전략: 프로그램 코드가 탑재되기 가장 적절한 크기의 메모리 공간에 탑재한다.
  * 최악 적합 전략: 가장 큰 메모리 공간에 프로그램 코드를 탑재한다.

* 메모리 할당과 회수가 계속 일어날 경우 할당 가능한 메모리 공간의 크기와 위치가 제각각이 되기때문에 적절한 관리가 필요하다.
  * 서로 인접해 있는 분할 된 메모리 공간을 통합한다.
  * 여러 곳에 분산되어 있는 사용중인 메모리 공간을 한 곳으로 모은다.



## 분산 메모리 할당 기법

> 하나의 프로그램이 분할된 메모리 공간 상에 흩어져서 적재되는 방법

### 페이징 기법

* 메모리를 **동일한 크기**의 **프레임**으로 분할하고 프로그램을 **프레임과 동일한 크기**의 **페이지**로 분할한다.

* 프로세스 실행에 필요한 페이지만 메모리에 적재하고 있다가 추가 페이지가 필요한 경우 메모리에 적재한다.
* 메모리 상에 연속적으로 적재되지않고 필요한 시점에 적재하기 때문에 적재된 지점의 메모리 주소를 알아야 프로세스에서 찾아쓸 수 있다.
* 따라서 페이지의 메모리 주소를 관리하고 있는 페이지 테이블이 프로세스마다 1개씩 존재한다.

* 페이지와 프레임의 크기가 동일하기 때문에 **외부단편화**가 발생하지 않는다.
* 하지만 프로그램의 크기가 페이지 분할크기와 딱 맞아 떨어지지 않아 **내부단편화**는 발생가능하다.(ex: 프로그램 크기 10MB, 페이지 크기 3MB인 경우 1MB크기의 페이지가 발생해 2MB의 내부단편화 발생 가능)

### 세그멘테이션 기법

* 메모리를 크기가 변할 수 있는 **세그먼트**로 분할하고 그 한도 내에서 프로그램 코드를 필요한 만큼 적재한다.
* 페이지 기법과 같이 혼용되어 프로세스 별로 세그먼트를 할당하여 메모리를 분할하고 세그먼트 내에서 페이징 기법으로 프로그램 코드를 적재한다.
* 메모리 -> 세그먼트로 분할, 세그먼트 -> 프레임으로 분할

