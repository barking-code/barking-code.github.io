---
layout: post
title: "병행 프로세스와 상호 배제"
categories:
  - Study
  - OS
tags:
  - OS
created_at: 2021-01-10T23:16:00+09:00
modified_at: 2021-01-11T20:57:00+09:00
visible: true
---

## 병행 프로세스란?

> 동시에 2개 이상의 프로세스가 실행되는 경우 해당 프로세스들을 병행 프로세스라고한다

* 프로세스는 독립적인 메모리를 할당받고 독립적인 작업을 수행하지만 두 개이상의 프로그램이 연계된 경우, 또는 하나의 프로그램이 멀티 프로세싱으로 동작하도록 작성되어 있는 경우 프로세스간의 협력, 통신이 필요하게 된다.
* 이 경우 공유하는 데이터에 접근하여 읽기, 쓰기, 삭제 등의 연산을 수행하는 경우 DB의 동시성 제어와 유사한 문제점이 발생하게 된다(쓰기가 완료되지 않은 데이터에 다른 프로세스가 접근하는 등).
* 이렇게 공유하는 데이터에 접근하여 연산을 수행할 때, 그 순서에 따라 결과가 달라지는 상황을 경쟁 조건(race condition)이라고 한다.

* 경쟁 조건을 발생시키는 다수의 프로세스 수행 과정에서 제대로된 프로그램 설계가 이루어지지 않은 경우 예상과는 다른 결과가 발생할 수 있기때문에 주의가 필요하다.

### 병행 프로세스가 적절히 수행되기 위한 조건

1. 상호 배제 조건
   * 2개 이상의 프로세스가 동시에 임계 영역에 있어서는 안됨
2. 진행 조건
   * 임계 구역 밖의 프로세스가 다른 프로세스의 임계 구역 진입을 막아서는 안됨
3. 한계 대기 조건
   * 프로세스가 입계 구역을 진입하는 것이 무한정 연기되어서는 안됨
4. 동일 속도 조건
   * 프로세스의 진행 속도에 어떠한 가정도 하지 않음(동일한 속도로 수행된다고 생각)

---

## 상호 배제

* 다수의 프로세스가 하나의 공통된 데이터에 접근 할 경우 순서에 맞게 연산을 수행 하도록 다른 프로세스가 접근하지 못하게 막아야하는 경우가 필요하다
* 현재 작업을 수행하는 프로세스가 다른 프로세스가 공통된 데이터에 접근하지 못하도록 막는 것을 상호 배제(mutual exclusive)라고 한다.

---

## 임계 영역

* 다수의 프로세스가 공통된 하나의 데이터에 접근하는 부분(프로그램 코드)을 임계영역이라고 한다.
* 다수의 프로세스가 각각 수행하는 연산에서 임계영역을 동시에 수행하게 될 경우 공통 데이터를 참조하게 되므로 경쟁 조건이 발생하게 된다.
* 또한 프로세스가 서로 필요한 공통 데이터를 접근하여 무한정 대기하게되는 교착상태가 발생하기도 한다.
* 따라서 다수의 프로세스가 동시에 임계 영역에 접근하지 않도록 조절해야 한다.
* 임계 영역이 존재하는 프로세스는 임계 영역 진입전 다른 프로세스가 임계 영역에 존재하는지 확인 후 임계 영역에 존재하는 프로세스가 없을 때만 진입 가능하도록 해야한다.

---

## 상호 배제 알고리즘

### 데커 알고리즘

```c
// 프로세스 P0, P1의 공유 변수
bool flag[2];  // 임계영역에 진입할 의사를 표시하는 배열, 초기값 false
int turn;      // 임계영역에 진입할 수 있는 프로세스의 차례를 나타냄, 0 또는 1

// 프로세스 Pi내부
while (1) {
    // 임계영역으로 진입 가능 여부 판단
    flag[i] = true;              // Pi가 임계영역에 진입할 의사가 있음을 체크
    while (flag[j]) {            // Pj가 임계영역에 진입할 의사가 있는 경우
        if (turn == j) {         // Pj가 진입할 차례이면
            flag[i] = false;     // Pi는 Pj가 임계영역에 진입할 수 있도록 진입 의사를 철회함
            while (turn == j) {  // Pj가 임계영역에서 작업을 수행하는 동안
                flag[i] = true;  // 임계영역에 진입할 의사를 밝히고 기다림
        }
    }
    // 임계영역 작업 수행
    ...
    turn = j;                    // 임계영역 진입 차례를 Pj에 넘김
    flag[i] = false;             // 임계영역 진입 의사를 철회한다.
}
```



### 피터슨 알고리즘

```c
// 프로세스 P0, P1의 공유 변수
bool flag[2];  // 임계영역에 진입할 의사를 표시하는 배열, 초기값 false
int turn;      // 임계영역에 진입할 수 있는 프로세스의 차례를 나타냄, 0 또는 1

// 프로세스 Pi 내부
while (1) {
    // 임계영역으로 진입 가능 여부 판단
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j) {}; // Pj가 임계영역에 진입할 의사가 있고 Pj 진입 차례인 경우 Pi는 계속 차례를 대기함
    // 임계영역 작업 수행
    ...
    flag[i] = false;                 // 작업 완료 후 임계 영역 진입 의사를 철회한다
}
```



### 세마포어(Semaphore)

* 특수한 변수인 세마포어를 사용해 교착 상태를 해결한다.

#### 2진 세마포어

```c++
// semaphore 정의
class Semaphore {
	private int value; // 현재 임계영역에 진입 가능 여부
    
    public Semaphore(int value) {
        this.value = value;
    }
    
    public void wait() {
        while (this.value <= 0) {};  // 진입 불가능할 경우 계속 대기
        this.value--;				 // value를 1 줄이고 wait 끝내기(프로세스에서 임계영역 진입)
    }
    
    public void signal() {
        this.value++;				// 임계영역에서 작업이 끝난 프로세스에서 신호를 발생
    }
}

// 공유 변수(Semaphore) S 생성 및 초기화
Semaphore S = new Semaphore(1);

// 프로세스 Pi 내부
while (1) {
    S.wait();    			// S.value가 0일 경우 이 라인에서 Block되기 때문에 무한 대기
    // 임계영역 작업 수행
    ...			 			// 다른 프로세스가 임계영역에서 작업 완료시 S.value가 1이 되어 임계영역 진입 가능
    S.signal();				// 임계영역에서 작업 수행 완료시 S.value를 1로 되돌려 놓아 다른 프로세스가 임계영역에 진입가능하도록 함
}
```

* 2진 세마포어의 경우 wait()시 while문이 계속 반복되어 자원이 낭비, 다수의 프로세스가 경쟁시 임계영역 진입우선 순위를 결정 할 수 없다.

#### 큐를 활용한 세마포어

```java
// semaphore 정의
class Semaphore {
	private int value; // 현재 임계영역에 진입 가능 여부 판별
    private Queue<Process> ProcessQueue;
    
    public Semaphore(int value) {
        this.value = value;
    }
    
    public void wait() {
        this.value--;						// 임계영역 진입 의사를 알림
        if (this.value < 0) {
            ProcessQueue.push(thisProcess); // 현재 프로세스를 ProcessQueue에 추가
            thisProcess.block();			// 그 후현재 프로세스를 block상태로 변경
        }
    }
    
    public void signal() {
        this.value++;						// 임계영역내 작업 수행 완료를 알림
        if (this.value <= 0) {
            Process nextProcess = ProcessQueue.pop();	// 다음에 임계영역에 진입 할 프로세스를 꺼냄
            nextProcess.run();				// 다음 프로세스 임계영역으로 진입
        }
    }
}
```

